package rekordbox

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"

	nulltype "github.com/mattn/go-nulltype"
)

// DjmdSharedPlaylistUser represents a row from 'djmdSharedPlaylistUser'.
type DjmdSharedPlaylistUser struct {
	ID                  string              `json:"id"`                    // ID
	MemberType          nulltype.NullInt64  `json:"member_type"`           // member_type
	MemberID            string              `json:"member_id"`             // member_id
	Status              nulltype.NullInt64  `json:"status"`                // status
	InvitationExpiresAt *Time               `json:"invitation_expires_at"` // invitation_expires_at
	InvitedAt           *Time               `json:"invited_at"`            // invited_at
	JoinedAt            *Time               `json:"joined_at"`             // joined_at
	Int1                nulltype.NullInt64  `json:"int1"`                  // int_1
	Int2                nulltype.NullInt64  `json:"int2"`                  // int_2
	Str1                nulltype.NullString `json:"str1"`                  // str_1
	Str2                nulltype.NullString `json:"str2"`                  // str_2
	Text1               nulltype.NullString `json:"text1"`                 // text_1
	Text2               nulltype.NullString `json:"text2"`                 // text_2
	CreatedAt           Time                `json:"created_at"`            // created_at
	UpdatedAt           Time                `json:"updated_at"`            // updated_at
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the DjmdSharedPlaylistUser exists in the database.
func (dspu *DjmdSharedPlaylistUser) Exists() bool {
	return dspu._exists
}

// Deleted returns true when the DjmdSharedPlaylistUser has been marked for deletion from
// the database.
func (dspu *DjmdSharedPlaylistUser) Deleted() bool {
	return dspu._deleted
}

// Insert inserts the DjmdSharedPlaylistUser to the database.
func (c *Client) InsertDjmdSharedPlaylistUser(ctx context.Context, dspu *DjmdSharedPlaylistUser) error {
	db := c.db

	switch {
	case dspu._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case dspu._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (manual)
	const sqlstr = `INSERT INTO djmdSharedPlaylistUser (` +
		`ID, member_type, member_id, status, invitation_expires_at, invited_at, joined_at, int_1, int_2, str_1, str_2, text_1, text_2, created_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15` +
		`)`
	// run
	logf(sqlstr, dspu.ID, dspu.MemberType, dspu.MemberID, dspu.Status, dspu.InvitationExpiresAt, dspu.InvitedAt, dspu.JoinedAt, dspu.Int1, dspu.Int2, dspu.Str1, dspu.Str2, dspu.Text1, dspu.Text2, dspu.CreatedAt, dspu.UpdatedAt)
	if _, err := db.ExecContext(ctx, sqlstr, dspu.ID, dspu.MemberType, dspu.MemberID, dspu.Status, dspu.InvitationExpiresAt, dspu.InvitedAt, dspu.JoinedAt, dspu.Int1, dspu.Int2, dspu.Str1, dspu.Str2, dspu.Text1, dspu.Text2, dspu.CreatedAt, dspu.UpdatedAt); err != nil {
		return logerror(err)
	}
	// set exists
	dspu._exists = true
	return nil
}

// Update updates a DjmdSharedPlaylistUser in the database.
func (c *Client) UpdateDjmdSharedPlaylistUser(ctx context.Context, dspu *DjmdSharedPlaylistUser) error {
	db := c.db

	switch {
	case !dspu._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case dspu._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with primary key
	const sqlstr = `UPDATE djmdSharedPlaylistUser SET ` +
		`member_type = $1, status = $2, invitation_expires_at = $3, invited_at = $4, joined_at = $5, int_1 = $6, int_2 = $7, str_1 = $8, str_2 = $9, text_1 = $10, text_2 = $11, created_at = $12, updated_at = $13 ` +
		`WHERE ID = $14 AND member_id = $15`
	// run
	logf(sqlstr, dspu.MemberType, dspu.Status, dspu.InvitationExpiresAt, dspu.InvitedAt, dspu.JoinedAt, dspu.Int1, dspu.Int2, dspu.Str1, dspu.Str2, dspu.Text1, dspu.Text2, dspu.CreatedAt, dspu.UpdatedAt, dspu.ID, dspu.MemberID)
	if _, err := db.ExecContext(ctx, sqlstr, dspu.MemberType, dspu.Status, dspu.InvitationExpiresAt, dspu.InvitedAt, dspu.JoinedAt, dspu.Int1, dspu.Int2, dspu.Str1, dspu.Str2, dspu.Text1, dspu.Text2, dspu.CreatedAt, dspu.UpdatedAt, dspu.ID, dspu.MemberID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the DjmdSharedPlaylistUser to the database.
func (c *Client) SaveDjmdSharedPlaylistUser(ctx context.Context, dspu *DjmdSharedPlaylistUser) error {
	if dspu.Exists() {
		return c.UpdateDjmdSharedPlaylistUser(ctx, dspu)
	}
	return c.InsertDjmdSharedPlaylistUser(ctx, dspu)
}

// Upsert performs an upsert for DjmdSharedPlaylistUser.
func (c *Client) UpsertDjmdSharedPlaylistUser(ctx context.Context, dspu *DjmdSharedPlaylistUser) error {
	db := c.db

	switch {
	case dspu._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO djmdSharedPlaylistUser (` +
		`ID, member_type, member_id, status, invitation_expires_at, invited_at, joined_at, int_1, int_2, str_1, str_2, text_1, text_2, created_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15` +
		`)` +
		` ON CONFLICT (ID, member_id) DO ` +
		`UPDATE SET ` +
		`member_type = EXCLUDED.member_type, status = EXCLUDED.status, invitation_expires_at = EXCLUDED.invitation_expires_at, invited_at = EXCLUDED.invited_at, joined_at = EXCLUDED.joined_at, int_1 = EXCLUDED.int_1, int_2 = EXCLUDED.int_2, str_1 = EXCLUDED.str_1, str_2 = EXCLUDED.str_2, text_1 = EXCLUDED.text_1, text_2 = EXCLUDED.text_2, created_at = EXCLUDED.created_at, updated_at = EXCLUDED.updated_at `
	// run
	logf(sqlstr, dspu.ID, dspu.MemberType, dspu.MemberID, dspu.Status, dspu.InvitationExpiresAt, dspu.InvitedAt, dspu.JoinedAt, dspu.Int1, dspu.Int2, dspu.Str1, dspu.Str2, dspu.Text1, dspu.Text2, dspu.CreatedAt, dspu.UpdatedAt)
	if _, err := db.ExecContext(ctx, sqlstr, dspu.ID, dspu.MemberType, dspu.MemberID, dspu.Status, dspu.InvitationExpiresAt, dspu.InvitedAt, dspu.JoinedAt, dspu.Int1, dspu.Int2, dspu.Str1, dspu.Str2, dspu.Text1, dspu.Text2, dspu.CreatedAt, dspu.UpdatedAt); err != nil {
		return logerror(err)
	}
	// set exists
	dspu._exists = true
	return nil
}

// Delete deletes the DjmdSharedPlaylistUser from the database.
func (c *Client) DeleteDjmdSharedPlaylistUser(ctx context.Context, dspu *DjmdSharedPlaylistUser) error {
	db := c.db

	switch {
	case !dspu._exists: // doesn't exist
		return nil
	case dspu._deleted: // deleted
		return nil
	}
	// delete with composite primary key
	const sqlstr = `DELETE FROM djmdSharedPlaylistUser ` +
		`WHERE ID = $1 AND member_id = $2`
	// run
	logf(sqlstr, dspu.ID, dspu.MemberID)
	if _, err := db.ExecContext(ctx, sqlstr, dspu.ID, dspu.MemberID); err != nil {
		return logerror(err)
	}
	// set deleted
	dspu._deleted = true
	return nil
}

func scanDjmdSharedPlaylistUserRows(rows *sql.Rows) ([]*DjmdSharedPlaylistUser, error) {
	var res []*DjmdSharedPlaylistUser
	for rows.Next() {
		dspu := DjmdSharedPlaylistUser{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&dspu.ID, &dspu.MemberType, &dspu.MemberID, &dspu.Status, &dspu.InvitationExpiresAt, &dspu.InvitedAt, &dspu.JoinedAt, &dspu.Int1, &dspu.Int2, &dspu.Str1, &dspu.Str2, &dspu.Text1, &dspu.Text2, &dspu.CreatedAt, &dspu.UpdatedAt); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &dspu)
	}

	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

func (c *Client) AllDjmdSharedPlaylistUser(ctx context.Context) ([]*DjmdSharedPlaylistUser, error) {
	db := c.db

	const sqlstr = `SELECT * FROM DjmdSharedPlaylistUser`
	rows, err := db.QueryContext(ctx, sqlstr)
	if err != nil {
		return nil, logerror(err)
	}

	defer rows.Close()
	res, err := scanDjmdSharedPlaylistUserRows(rows)
	if err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// DjmdSharedPlaylistUserByIDMemberID retrieves a row from 'djmdSharedPlaylistUser' as a DjmdSharedPlaylistUser.
//
// Generated from index 'sqlite_autoindex_djmdSharedPlaylistUser_1'.
func (c *Client) DjmdSharedPlaylistUserByIDMemberID(ctx context.Context, id, memberID string) (*DjmdSharedPlaylistUser, error) {
	// func DjmdSharedPlaylistUserByIDMemberID(ctx context.Context, db DB, id string, memberID string) (*DjmdSharedPlaylistUser, error) {
	db := c.db

	// query
	const sqlstr = `SELECT ` +
		`ID, member_type, member_id, status, invitation_expires_at, invited_at, joined_at, int_1, int_2, str_1, str_2, text_1, text_2, created_at, updated_at ` +
		`FROM djmdSharedPlaylistUser ` +
		`WHERE ID = $1 AND member_id = $2`
	// run
	logf(sqlstr, id, memberID)
	dspu := DjmdSharedPlaylistUser{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, id, memberID).Scan(&dspu.ID, &dspu.MemberType, &dspu.MemberID, &dspu.Status, &dspu.InvitationExpiresAt, &dspu.InvitedAt, &dspu.JoinedAt, &dspu.Int1, &dspu.Int2, &dspu.Str1, &dspu.Str2, &dspu.Text1, &dspu.Text2, &dspu.CreatedAt, &dspu.UpdatedAt); err != nil {
		return nil, logerror(err)
	}
	return &dspu, nil
}
